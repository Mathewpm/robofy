from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import os
import json
from datetime import datetime
import logging
from sqlalchemy.orm import Session

# Import database models and session
from database import get_db, Lead as LeadModel, Content as ContentModel, create_tables

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Robofy Backend API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://robofy.uk"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class LeadCreate(BaseModel):
    name: str
    email: str
    industry: Optional[str] = None
    source: Optional[str] = None

class LeadResponse(LeadCreate):
    id: int
    score: int
    created_at: datetime
    updated_at: datetime

class ContentGenerateRequest(BaseModel):
    title: str
    industry: str
    content_type: str  # blog, industry_page, service, etc.

class ContentResponse(BaseModel):
    id: int
    title: str
    content: str
    industry: str
    status: str
    created_at: datetime
    published_at: Optional[datetime] = None

# Create database tables on startup
@app.on_event("startup")
def on_startup():
    create_tables()
    logger.info("Database tables created (if not exists)")

@app.get("/")
async def root():
    return {"message": "Robofy Backend API is running"}

@app.get("/api/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now()}

@app.post("/api/leads", response_model=LeadResponse)
async def create_lead(lead: LeadCreate, db: Session = Depends(get_db)):
    try:
        # Check if email already exists
        existing_lead = db.query(LeadModel).filter(LeadModel.email == lead.email).first()
        if existing_lead:
            raise HTTPException(status_code=400, detail="Lead with this email already exists")
        
        # Create new lead
        db_lead = LeadModel(
            name=lead.name,
            email=lead.email,
            industry=lead.industry,
            source=lead.source,
            score=0
        )
        db.add(db_lead)
        db.commit()
        db.refresh(db_lead)
        
        logger.info(f"New lead created: {db_lead.email}")
        return db_lead
    except Exception as e:
        logger.error(f"Error creating lead: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get("/api/leads", response_model=List[LeadResponse])
async def get_leads(db: Session = Depends(get_db)):
    leads = db.query(LeadModel).all()
    return leads

@app.post("/api/ai/content", response_model=ContentResponse)
async def generate_content(request: ContentGenerateRequest, db: Session = Depends(get_db)):
    try:
        # Placeholder for AI content generation
        # In production, integrate with AI services like OpenAI, Hugging Face, etc.
        ai_generated_content = f"""
        # {request.title}
        
        This is AI-generated content for the {request.industry} industry.
        Generated on {datetime.now().strftime('%Y-%m-%d')}.
        
        ## Key Benefits
        - Automated content creation
        - Industry-specific insights
        - SEO optimized structure
        
        *This content was generated by Robofy's AI autoblogging system.*
        """
        
        # Create new content in database
        db_content = ContentModel(
            title=request.title,
            content=ai_generated_content,
            industry=request.industry,
            status="published",
            published_at=datetime.now()
        )
        db.add(db_content)
        db.commit()
        db.refresh(db_content)
        
        # Save content to file for Next.js consumption
        content_dir = "../src/content"
        os.makedirs(content_dir, exist_ok=True)
        
        filename = f"{request.content_type}_{request.industry.lower().replace(' ', '_')}_{db_content.id}.md"
        filepath = os.path.join(content_dir, filename)
        
        with open(filepath, "w") as f:
            f.write(ai_generated_content)
        
        logger.info(f"Content generated and saved: {filepath}")
        return db_content
    except Exception as e:
        logger.error(f"Error generating content: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get("/api/content", response_model=List[ContentResponse])
async def get_content(db: Session = Depends(get_db)):
    content = db.query(ContentModel).all()
    return content

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)